package rapidproxy

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

// createTestServer creates a simple test HTTP server
func createTestServer() *httptest.Server {
	return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("test response"))
	}))
}

// TestNew tests pool creation
func TestNew(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	config := &Config{
		ProxyURLs:         []string{server.URL},
		NumWorkers:        10,
		QueueSize:         100,
		RateLimitPerProxy: 10,
	}

	pool, err := New(config)
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}
	defer pool.Close()

	if pool == nil {
		t.Fatal("Expected non-nil pool")
	}

	if pool.manager == nil {
		t.Error("Expected manager to be initialized")
	}

	if pool.selector == nil {
		t.Error("Expected selector to be initialized")
	}

	if pool.workerPool == nil {
		t.Error("Expected worker pool to be initialized")
	}

	if pool.collector == nil {
		t.Error("Expected collector to be initialized")
	}
}

// TestNew_DefaultConfig tests creation with nil config
func TestNew_DefaultConfig(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	config := DefaultConfig()
	config.ProxyURLs = []string{server.URL}

	pool, err := New(config)
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}
	defer pool.Close()

	if pool == nil {
		t.Fatal("Expected non-nil pool")
	}
}

// TestNew_InvalidConfig tests creation with invalid config
func TestNew_InvalidConfig(t *testing.T) {
	tests := []struct {
		name   string
		config *Config
	}{
		{
			name:   "no proxies",
			config: &Config{ProxyURLs: []string{}},
		},
		{
			name: "negative workers",
			config: &Config{
				ProxyURLs:  []string{"http://proxy1:8080"},
				NumWorkers: -1,
			},
		},
		{
			name: "negative queue size",
			config: &Config{
				ProxyURLs:  []string{"http://proxy1:8080"},
				NumWorkers: 10,
				QueueSize:  -1,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := New(tt.config)
			if err == nil {
				t.Error("Expected error for invalid config")
			}
		})
	}
}

// TestDo tests single request execution
func TestDo(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	config := DefaultConfig()
	config.ProxyURLs = []string{server.URL}
	config.NumWorkers = 5
	config.QueueSize = 10

	pool, err := New(config)
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}
	defer pool.Close()

	// Create request
	req, _ := http.NewRequest("GET", server.URL+"/test", nil)

	// Execute request
	result, err := pool.Do(req)
	if err != nil {
		t.Fatalf("Do failed: %v", err)
	}

	if result == nil {
		t.Fatal("Expected non-nil result")
	}

	if result.ProxyUsed == "" {
		t.Error("Expected ProxyUsed to be set")
	}

	if result.Latency <= 0 {
		t.Error("Expected positive latency")
	}

	// Check response
	if result.Response == nil {
		t.Fatal("Expected non-nil response")
	}

	if result.Response.StatusCode != http.StatusOK {
		t.Errorf("Expected status 200, got %d", result.Response.StatusCode)
	}

	if len(result.Body) == 0 {
		t.Error("Expected non-empty body")
	}
}

// TestDoWithContext_Timeout tests request with timeout
func TestDoWithContext_Timeout(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	pool, err := New(&Config{
		ProxyURLs:  []string{server.URL},
		NumWorkers: 5,
		QueueSize:  10,
		RateLimitPerProxy: 10,
	})
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}
	defer pool.Close()

	// Create request with very short timeout
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Nanosecond)
	defer cancel()

	time.Sleep(10 * time.Millisecond) // Ensure context is cancelled

	req, _ := http.NewRequest("GET", server.URL+"/test", nil)

	// Should return context error
	_, err = pool.DoWithContext(ctx, req)
	if err == nil {
		t.Error("Expected error for cancelled context")
	}
}

// TestDoBatch tests batch request execution
func TestDoBatch(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	pool, err := New(&Config{
		ProxyURLs:  []string{server.URL},
		NumWorkers: 10,
		QueueSize:  100,
		RateLimitPerProxy: 10,
	})
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}
	defer pool.Close()

	// Create batch of requests
	numRequests := 10
	requests := make([]*http.Request, numRequests)
	for i := 0; i < numRequests; i++ {
		requests[i], _ = http.NewRequest("GET", server.URL+"/test", nil)
	}

	// Execute batch
	results, err := pool.DoBatch(requests)
	if err != nil {
		t.Fatalf("DoBatch failed: %v", err)
	}

	if len(results) != numRequests {
		t.Errorf("Expected %d results, got %d", numRequests, len(results))
	}

	// Check results
	for i, result := range results {
		if result == nil {
			t.Errorf("Result %d is nil", i)
			continue
		}

		if result.Response != nil && result.Response.StatusCode == http.StatusOK {
			// Success
			continue
		}

		// May have error if proxy failed, but result should exist
		if result.Error == nil && result.Response == nil {
			t.Errorf("Result %d has neither response nor error", i)
		}
	}
}

// TestStats tests statistics collection
func TestStats(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	pool, err := New(&Config{
		ProxyURLs:  []string{server.URL},
		NumWorkers: 10,
		QueueSize:  100,
		RateLimitPerProxy: 10,
	})
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}
	defer pool.Close()

	// Get stats
	stats := pool.Stats()

	if stats == nil {
		t.Fatal("Expected non-nil stats")
	}

	if stats.TotalProxies != 1 {
		t.Errorf("Expected 1 proxy, got %d", stats.TotalProxies)
	}

	if stats.WorkerCount != 10 {
		t.Errorf("Expected 10 workers, got %d", stats.WorkerCount)
	}

	if stats.Uptime <= 0 {
		t.Error("Expected positive uptime")
	}
}

// TestProxyStats tests per-proxy statistics
func TestProxyStats(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	pool, err := New(&Config{
		ProxyURLs:  []string{server.URL},
		NumWorkers: 5,
		QueueSize:  10,
		RateLimitPerProxy: 10,
	})
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}
	defer pool.Close()

	// Get proxy stats
	proxyStats := pool.ProxyStats()

	if len(proxyStats) != 1 {
		t.Fatalf("Expected 1 proxy stat, got %d", len(proxyStats))
	}

	stat := proxyStats[0]
	if stat.ProxyURL != server.URL {
		t.Errorf("Expected proxy URL %s, got %s", server.URL, stat.ProxyURL)
	}

	if stat.State != "healthy" {
		t.Errorf("Expected healthy state, got %s", stat.State)
	}
}

// TestClose tests graceful shutdown
func TestClose(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	pool, err := New(&Config{
		ProxyURLs:  []string{server.URL},
		NumWorkers: 5,
		QueueSize:  10,
		RateLimitPerProxy: 10,
	})
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}

	// Close pool
	err = pool.Close()
	if err != nil {
		t.Errorf("Close failed: %v", err)
	}

	// Subsequent operations should fail
	req, _ := http.NewRequest("GET", server.URL+"/test", nil)
	_, err = pool.Do(req)
	if err == nil {
		t.Error("Expected error after close")
	}
}

// TestConcurrent tests concurrent request execution
func TestConcurrent(t *testing.T) {
	server := createTestServer()
	defer server.Close()

	pool, err := New(&Config{
		ProxyURLs:  []string{server.URL},
		NumWorkers: 20,
		QueueSize:  200,
		RateLimitPerProxy: 10,
	})
	if err != nil {
		t.Fatalf("Failed to create pool: %v", err)
	}
	defer pool.Close()

	// Submit many concurrent requests
	numRequests := 50
	results := make(chan *Result, numRequests)
	errors := make(chan error, numRequests)

	for i := 0; i < numRequests; i++ {
		go func() {
			req, _ := http.NewRequest("GET", server.URL+"/test", nil)
			result, err := pool.Do(req)
			if err != nil {
				errors <- err
			} else {
				results <- result
			}
		}()
	}

	// Collect results
	successCount := 0
	errorCount := 0

	for i := 0; i < numRequests; i++ {
		select {
		case <-results:
			successCount++
		case <-errors:
			errorCount++
		case <-time.After(5 * time.Second):
			t.Fatal("Timeout waiting for results")
		}
	}

	// Most should succeed
	if successCount < numRequests/2 {
		t.Errorf("Expected at least %d successes, got %d", numRequests/2, successCount)
	}
}
